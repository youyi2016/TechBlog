(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{256:function(t,e,v){"use strict";v.r(e);var _=v(0),o=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"为什么要有依赖收集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有依赖收集"}},[t._v("#")]),t._v(" 为什么要有依赖收集")]),t._v(" "),v("p",[v("strong",[t._v("前言：")])]),t._v(" "),v("p",[t._v("vue 框架 是一个 js 库。vue 是一个类对象，通过 new 来创建 vue 实例。创建 vue 实例时里面包含了一系列的初始化操作：")]),t._v(" "),v("p",[t._v("1、vue 实例的挂载")]),t._v(" "),v("p",[t._v("2、变量对象设置成响应式")]),t._v(" "),v("p",[t._v("3、模版转化成 dom")]),t._v(" "),v("p",[t._v("vue 模版到 dom 的流程：")]),t._v(" "),v("p",[t._v("组件模版->template 模版->ast 抽象语法树->complier 编译函数生成->虚拟 Dom 渲染函数->结合响应式系统生成最少 组件和减少 dom 操作")]),t._v(" "),v("p",[v("strong",[t._v("为什么要有依赖收集？")])]),t._v(" "),v("p",[t._v("vue 双向数据绑定的核心是 Object.definedProperty，在初始化阶段会将 data 中的变量通过该方法将变量设置成响应式的（重新定义）。当读取变量时会触发对应的 get 方法，当为变量赋值时会触发对应的 set 方法，触发 set 方法时会重新渲染 dom。如果 data 中的变量没有在 dom 中渲染，变量数据改变又触发 dom 重新渲染，就造成了不必要的 dom 渲染。")]),t._v(" "),v("p",[t._v("依赖收集的作用就是只让在 dom 中使用了的变量的数据改变时派发更新 对应的 dom。")]),t._v(" "),v("p",[v("strong",[t._v("如何进行依赖收集？")])]),t._v(" "),v("p",[t._v("具体细节：")]),t._v(" "),v("p",[t._v("1、全局有一个依赖收集的类 Dep，专门用来收集所有的依赖（一个订阅发布者模式的类）。")]),t._v(" "),v("p",[t._v("2、 Watch 类用来更新 dom。")]),t._v(" "),v("p",[t._v("3、第一次 render 时读取变量就会调用变量对应的 getter 方法，在 getter 方法中进行依赖收集。")]),t._v(" "),v("p",[t._v("4、当初始化 vue 实例时，会创建一个 Watcher 对象，并将观察者本身保存在用于依赖收集的全局变量 Dep 的 target 属性上（Dep.target=this）,在调用")]),t._v(" "),v("p",[t._v("5、当改变 data 中的变量值时就会触发对应的 set 方法，触发 notify 方法更新 dom。")]),t._v(" "),v("p",[t._v("2020-01-15")])])}),[],!1,null,null,null);e.default=o.exports}}]);