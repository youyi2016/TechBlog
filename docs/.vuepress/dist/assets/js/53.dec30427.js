(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{256:function(e,n,t){"use strict";t.r(n);var r=t(0),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"模版编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模版编译"}},[e._v("#")]),e._v(" 模版编译")]),e._v(" "),t("h3",{attrs:{id:"vue-是如何将模版转换成-html-的呢？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-是如何将模版转换成-html-的呢？"}},[e._v("#")]),e._v(" vue 是如何将模版转换成 html 的呢？")]),e._v(" "),t("p",[e._v("模版---\x3east(抽象树)--\x3erender 函数->虚拟 dom->实际 dom")]),e._v(" "),t("p",[e._v("compiler 指令编辑器将模版编译成 ast（用于表示模版的 js 对象），再将 ast 转化成 render 函数，再将 render 函数转化成虚拟 dom，然后再将虚拟 dom 通过 diff 算法优化后转化成实际 dom。")]),e._v(" "),t("p",[e._v("ast 是一种表示源代码的 js 对象（描述 dom 结构的 js 对象）。通过 compiler 编译生成 render 函数，render 函数用来生成虚拟节点 vnode（用来描述节点及其子节点的信息），render 函数的格式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("render: function (createElement) {\n\treturn createElement('h1', this.blogTitle)\n}\n")])])]),t("p",[e._v("createElement 格式")]),e._v(" "),t("div",{staticClass:"language-vue extra-class"},[t("pre",{pre:!0,attrs:{class:"language-vue"}},[t("code",[e._v("// @returns {VNode} createElement( // {String | Object | Function} // 一个 HTML\n标签名、组件选项对象，或者 // resolve 了上述任何一种的一个 async 函数。必填项。\n'div', // {Object} // 一个与模板中属性对应的数据对象。可选。 { // (详情见下一节)\n}, // {String | Array} // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，\n// 也可以使用字符串来生成“文本虚拟节点”。可选。 [ '先写一些文字',\ncreateElement('h1', '一则头条'), createElement(MyComponent, { props: { someProp:\n'foobar' } }) ] )\n")])])]),t("p",[e._v("createElement 第二个参数是节点的属性：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  // 与 `v-bind:class` 的 API 相同，\n  // 接受一个字符串、对象或字符串和对象组成的数组\n  'class': {\n    foo: true,\n    bar: false\n  },\n  // 与 `v-bind:style` 的 API 相同，\n  // 接受一个字符串、对象，或对象组成的数组\n  style: {\n    color: 'red',\n    fontSize: '14px'\n  },\n  // 普通的 HTML 特性\n  attrs: {\n    id: 'foo'\n  },\n  // 组件 prop\n  props: {\n    myProp: 'bar'\n  },\n  // DOM 属性\n  domProps: {\n    innerHTML: 'baz'\n  },\n  // 事件监听器在 `on` 属性内，\n  // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。\n  // 需要在处理函数中手动检查 keyCode。\n  on: {\n    click: this.clickHandler\n  },\n  // 仅用于组件，用于监听原生事件，而不是组件内部使用\n  // `vm.$emit` 触发的事件。\n  nativeOn: {\n    click: this.nativeClickHandler\n  },\n  // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`\n  // 赋值，因为 Vue 已经自动为你进行了同步。\n  directives: [\n    {\n      name: 'my-custom-directive',\n      value: '2',\n      expression: '1 + 1',\n      arg: 'foo',\n      modifiers: {\n        bar: true\n      }\n    }\n  ],\n  // 作用域插槽的格式为\n  // { name: props => VNode | Array<VNode> }\n  scopedSlots: {\n    default: props => createElement('span', props.text)\n  },\n  // 如果组件是其它组件的子组件，需为插槽指定名称\n  slot: 'name-of-slot',\n  // 其它特殊顶层属性\n  key: 'myKey',\n  ref: 'myRef',\n  // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，\n  // 那么 `$refs.myRef` 会变成一个数组。\n  refInFor: true\n}\n")])])]),t("p",[e._v("第三个是子元素。")]),e._v(" "),t("p",[e._v("vue 组件建立起来的整个 vnode 树叫虚拟 dom 树。")])])}),[],!1,null,null,null);n.default=a.exports}}]);